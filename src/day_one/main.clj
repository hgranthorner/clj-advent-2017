(ns day-one
  (:require [clojure.test :refer :all]
            [clojure.string :as str]))

(def sample "1122")
(def input "36743676522426214741687639282183216978128565594112364817283598621384839756628424146779311928318383597235968644687665159591573413233616717112157752469191845757712928347624726438516211153946892241449523148419426259291788938621886334734497823163281389389853675932246734153563861233894952657625868415432316155487242813798425779743561987563734944962846865263722712768674838244444385768568489842989878163655771847362656153372265945464128668412439248966939398765446171855144544285463517258749813731314365947372548811434646381595273172982466142248474238762554858654679415418693478512641864168398722199638775667744977941183772494538685398862344164521446115925528534491788728448668455349588972443295391385389551783289417349823383324748411689198219329996666752251815562522759374542652969147696419669914534586732436912798519697722586795746371697338416716842214313393228587413399534716394984183943123375517819622837972796431166264646432893478557659387795573234889141897313158457637142238315327877493994933514112645586351127139429281675912366669475931711974332271368287413985682374943195886455927839573986464555141679291998645936683639162588375974549467767623463935561847869527383395278248952314792112113126231246742753119748113828843917812547224498319849947517745625844819175973986843636628414965664466582172419197227695368492433353199233558872319529626825788288176275546566474824257336863977574347328469153319428883748696399544974133392589823343773897313173336568883385364166336362398636684459886283964242249228938383219255513996468586953519638111599935229115228837559242752925943653623682985576323929415445443378189472782454958232341986626791182861644112974418239286486722654442144851173538756859647218768134572858331849543266169672745221391659363674921469481143686952478771714585793322926824623482923579986434741714167134346384551362664177865452895348948953472328966995731169672573555621939584872187999325322327893336736611929752613241935211664248961527687778371971259654541239471766714469122213793348414477789271187324629397292446879752673")

(defn stagger
  [input]
  "
  Accepts a list and returns a list of pairs
  [1 2 3 4] -> [[1 2] [2 3] [3 4]]
  "
  (loop [[hd snd & rest] input
         acc []]
    (if (nil? snd)
      acc
      (recur (cons snd rest) (conj acc [hd snd])))))

(comment
  (stagger [1 2 3])
  )

(defn maybe-combine
  [acc [num1 num2]] 
  (if (= num1 num2) (+ acc num1) acc))

(defn puzzle-one
  [input]
  "
  Accepts an input (a string of numbers) and returns the appropriate answer.
  "
  (let [nums  (map #(Integer/parseInt %)(str/split input #""))
        fst (first nums)
        lst (last nums)
        total (->> nums
                (stagger)
                (reduce #(maybe-combine %1 %2) 0))]
    (if (= fst lst)
      (+ total fst)
      total)))

(defn wrapped-get
  "
  Gets the nth character, wrapped around the end of the list.
  "
  [xs index]
  (let [len (count xs)]
    (if (>= index len)
      (get xs (- index len))
      (get xs index))))

(wrapped-get [1 1 1 1] 2)

(defn inspect
  [x]
  (println x)
  x)

(defn puzzle-two
  [input]
  (as-> (map #(Integer/parseInt %) (str/split input #"")) xs
    (vec (map-indexed #(conj [] %1 %2) xs))
    (reduce (fn [acc [ix x]]
              (let [nextix (+ ix (/ (count xs) 2))]
                (maybe-combine acc [x (last (wrapped-get xs nextix))]))) 0 xs)))

(comment
  (puzzle-two "123123")
  (puzzle-two input)
  (str/split "123" #"")
  (puzzle-one sample)
  (puzzle-one "91212129")
  (puzzle-one "1111")
  (puzzle-one input)
  )

(deftest test-puzzle-one
  (let [solution (puzzle-one "1122")
        pairs (stagger [1 2 3 4])
        wrapped1 (wrapped-get [1 2] 3)
        wrapped2 (wrapped-get [1 2 3] 1)]
    (is (= solution 3))
    (is (= pairs [[1 2] [2 3] [3 4]]))
    (is (= wrapped1 2))
    (is (= wrapped2 2))
    ))